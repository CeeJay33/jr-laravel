# ============================================
# NGINX MAIN CONFIGURATION
# ============================================
#
# PURPOSE: Global Nginx settings
# LOCATION: docker/nginx.conf
# COPIED TO: /etc/nginx/nginx.conf (in container)
#
# WHAT IS NGINX:
# - Web server (like Apache)
# - Reverse proxy
# - Load balancer
# - Very fast, lightweight
#
# WHY NGINX FOR LARAVEL:
# - Better performance than Apache
# - Lower memory usage
# - Better handling of concurrent connections
# - Industry standard for modern PHP

# ============================================
# USER AND PROCESS SETTINGS
# ============================================

# user www-data;
#
# WHAT IT DOES:
# - Nginx worker processes run as www-data user
# - www-data is standard non-root web user
#
# WHY NOT ROOT:
# - Security: if Nginx compromised, attacker only has www-data permissions
# - Can't modify system files
# - Can't open privileged ports
#
# NOTE: Master process still runs as root (needed to bind port 80)
user www-data;

# worker_processes auto;
#
# WHAT IT DOES:
# - Number of worker processes to spawn
# - auto: One per CPU core
#
# WHY AUTO:
# - Optimal performance
# - If server has 4 cores → 4 workers
# - Automatically scales with hardware
#
# ALTERNATIVES:
# - worker_processes 1; (for low-traffic)
# - worker_processes 4; (fixed number)
worker_processes auto;

# pid /run/nginx.pid;
#
# WHAT IT DOES:
# - Store process ID in this file
# - Used for process management
#
# USAGE:
# cat /run/nginx.pid → Get Nginx PID
# kill -HUP $(cat /run/nginx.pid) → Reload config
pid /run/nginx.pid;

# ============================================
# EVENTS BLOCK (Connection Processing)
# ============================================

events {
    # worker_connections 1024;
    #
    # WHAT IT DOES:
    # - Max simultaneous connections per worker
    # - Total connections = workers × worker_connections
    #
    # EXAMPLE:
    # - 4 workers × 1024 connections = 4096 total
    #
    # WHY 1024:
    # - Good default for most applications
    # - Can handle moderate traffic
    #
    # INCREASE IF:
    # - High traffic site
    # - Many keep-alive connections
    # - But also increase: ulimit -n
    #
    # CALCULATION:
    # Each connection uses file descriptors
    # System limit: ulimit -n (usually 1024)
    # Make sure: worker_connections < ulimit
    worker_connections 1024;
}

# ============================================
# HTTP BLOCK (Web Server Configuration)
# ============================================

http {
    # ========================================
    # MIME TYPES
    # ========================================
    
    # include /etc/nginx/mime.types;
    #
    # WHAT IT DOES:
    # - Loads file extension to MIME type mappings
    # - .html → text/html
    # - .css → text/css
    # - .js → application/javascript
    #
    # WHY NEEDED:
    # - Browser needs to know file type
    # - Renders correctly
    # - Applies proper caching
    include /etc/nginx/mime.types;
    
    # default_type application/octet-stream;
    #
    # WHAT IT DOES:
    # - Fallback MIME type if extension not found
    # - application/octet-stream = binary download
    #
    # WHEN USED:
    # - Unknown file extensions
    # - Browser will download instead of display
    default_type application/octet-stream;

    # ========================================
    # LOGGING CONFIGURATION
    # ========================================
    
    # log_format main '...';
    #
    # WHAT IT DOES:
    # - Defines format for access logs
    # - What information to log per request
    #
    # VARIABLES:
    # $remote_addr: Client IP address
    # $remote_user: HTTP auth username (if any)
    # $time_local: Request timestamp
    # $request: Full request (GET /path HTTP/1.1)
    # $status: HTTP status code (200, 404, etc.)
    # $body_bytes_sent: Response size in bytes
    # $http_referer: Referring page
    # $http_user_agent: Browser/client info
    # $http_x_forwarded_for: Real IP if behind proxy
    #
    # EXAMPLE LOG LINE:
    # 192.168.1.1 - - [09/Jan/2025:14:30:00 +0000] "GET /api/v1/secrets HTTP/1.1" 200 512 "-" "curl/7.68.0" "-"
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';

    # access_log /var/log/nginx/access.log main;
    #
    # WHAT IT DOES:
    # - Write access logs to this file
    # - Use "main" format defined above
    #
    # VIEW LOGS:
    # tail -f /var/log/nginx/access.log
    # docker-compose logs -f app
    access_log /var/log/nginx/access.log main;
    
    # error_log /var/log/nginx/error.log warn;
    #
    # WHAT IT DOES:
    # - Write error logs to this file
    # - Log level: warn (warnings and errors)
    #
    # LOG LEVELS (low to high):
    # - debug: Everything (very verbose)
    # - info: Informational messages
    # - notice: Normal but significant
    # - warn: Warning messages
    # - error: Error messages
    # - crit: Critical errors
    # - alert: Immediate action required
    # - emerg: System unusable
    #
    # WHY WARN:
    # - Captures important issues
    # - Not too verbose
    # - Good for production
    error_log /var/log/nginx/error.log warn;

    # ========================================
    # PERFORMANCE SETTINGS
    # ========================================
    
    # sendfile on;
    #
    # WHAT IT DOES:
    # - Use sendfile() system call for file transfers
    # - Sends files directly from disk to network
    # - Bypasses user-space buffer
    #
    # WHY ENABLE:
    # - Much faster file serving
    # - Lower CPU usage
    # - Better for static files (CSS, JS, images)
    #
    # BENEFIT:
    # Normal: Read file → Copy to buffer → Send to network
    # sendfile: Send file directly to network
    sendfile on;
    
    # tcp_nopush on;
    #
    # WHAT IT DOES:
    # - Send HTTP response headers in one packet
    # - With beginning of file
    #
    # WHY ENABLE:
    # - Fewer network packets
    # - Better performance
    # - Lower latency
    #
    # REQUIRES: sendfile on
    tcp_nopush on;
    
    # tcp_nodelay on;
    #
    # WHAT IT DOES:
    # - Disable Nagle's algorithm
    # - Send data immediately, don't buffer
    #
    # WHY ENABLE:
    # - Lower latency for small packets
    # - Important for real-time applications
    # - Good for APIs (immediate responses)
    #
    # TRADE-OFF:
    # More packets, but lower latency
    tcp_nodelay on;
    
    # keepalive_timeout 65;
    #
    # WHAT IT DOES:
    # - Keep connections alive for 65 seconds
    # - Reuse connection for multiple requests
    #
    # WHY USEFUL:
    # - Faster subsequent requests (no new TCP handshake)
    # - Lower latency
    # - More efficient
    #
    # EXAMPLE:
    # Client requests: /api/v1/secrets (create)
    # Same connection used for: /api/v1/secrets/{id} (retrieve)
    # No need to reconnect
    #
    # TOO HIGH:
    # - Wastes server resources
    # - Connections stay open unnecessarily
    #
    # TOO LOW:
    # - More TCP handshakes
    # - Higher latency
    keepalive_timeout 65;
    
    # types_hash_max_size 2048;
    #
    # WHAT IT DOES:
    # - Hash table size for MIME types
    # - Performance tuning parameter
    #
    # WHY 2048:
    # - Good default for most setups
    # - Enough for all common MIME types
    #
    # INCREASE IF:
    # nginx: could not build the types_hash
    types_hash_max_size 2048;

    # ========================================
    # COMPRESSION (GZIP)
    # ========================================
    
    # gzip on;
    #
    # WHAT IT DOES:
    # - Enable gzip compression
    # - Compress responses before sending
    #
    # BENEFITS:
    # - Smaller response size (50-80% reduction)
    # - Faster page loads
    # - Lower bandwidth usage
    #
    # EXAMPLE:
    # 100KB JSON response → 20KB compressed
    gzip on;
    
    # gzip_vary on;
    #
    # WHAT IT DOES:
    # - Add "Vary: Accept-Encoding" header
    # - Tells caches to store compressed/uncompressed separately
    #
    # WHY NEEDED:
    # - Some clients don't support gzip
    # - Caches need to serve correct version
    gzip_vary on;
    
    # gzip_proxied any;
    #
    # WHAT IT DOES:
    # - Enable compression for proxied requests
    # - "any": Compress regardless of headers
    #
    # WHY:
    # - Works even behind load balancers
    # - Works with CDNs
    gzip_proxied any;
    
    # gzip_comp_level 6;
    #
    # WHAT IT DOES:
    # - Compression level (1-9)
    # - Higher = more compression, more CPU
    #
    # WHY 6:
    # - Good balance of compression vs CPU
    # - Level 6: ~10% more compression than level 1
    # - Level 9: Only ~1-2% more than level 6
    #
    # LEVELS:
    # - 1: Fastest, least compression
    # - 6: Recommended balance
    # - 9: Slowest, most compression
    gzip_comp_level 6;
    
    # gzip_types ...;
    #
    # WHAT IT DOES:
    # - Which MIME types to compress
    # - text/html is always compressed
    #
    # TYPES LISTED:
    # - text/plain: Plain text
    # - text/css: Stylesheets
    # - text/xml: XML documents
    # - text/javascript: JavaScript
    # - application/json: JSON APIs
    # - application/javascript: JS files
    # - application/xml+rss: RSS feeds
    # - application/rss+xml: RSS feeds
    # - font/truetype: Fonts
    # - font/opentype: Fonts
    # - application/vnd.ms-fontobject: Fonts
    # - image/svg+xml: SVG images
    #
    # DON'T COMPRESS:
    # - image/jpeg (already compressed)
    # - image/png (already compressed)
    # - video/* (already compressed)
    gzip_types text/plain text/css text/xml text/javascript 
               application/json application/javascript application/xml+rss 
               application/rss+xml font/truetype font/opentype 
               application/vnd.ms-fontobject image/svg+xml;

    # ========================================
    # INCLUDE SITE CONFIGURATIONS
    # ========================================
    
    # include /etc/nginx/http.d/*.conf;
    #
    # WHAT IT DOES:
    # - Load all .conf files from http.d/
    # - Separates site-specific config
    #
    # OUR FILE:
    # /etc/nginx/http.d/default.conf
    # Contains Laravel-specific routing
    #
    # WHY SEPARATE:
    # - Main config stays clean
    # - Easy to add more sites
    # - Can disable sites by renaming (site.conf.disabled)
    include /etc/nginx/http.d/*.conf;
}

# ============================================
# TESTING CONFIGURATION
# ============================================
#
# Test syntax:
# nginx -t
#
# Reload without downtime:
# nginx -s reload
#
# View running config:
# nginx -T
#
# ============================================
# MONITORING
# ============================================
#
# Check Nginx status:
# ps aux | grep nginx
#
# View active connections:
# netstat -an | grep :80 | wc -l
#
# Watch error log live:
# tail -f /var/log/nginx/error.log
#
# ============================================
# SECURITY CONSIDERATIONS
# ============================================
#
# ADD FOR PRODUCTION:
#
# 1. Hide Nginx version:
#    server_tokens off;
#
# 2. Limit request size:
#    client_max_body_size 10m;
#
# 3. Add security headers:
#    add_header X-Frame-Options "SAMEORIGIN";
#    add_header X-Content-Type-Options "nosniff";
#
# 4. Rate limiting:
#    limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;
#
# 5. SSL/TLS configuration:
#    ssl_protocols TLSv1.2 TLSv1.3;
#    ssl_ciphers HIGH:!aNULL:!MD5;
#
# ============================================