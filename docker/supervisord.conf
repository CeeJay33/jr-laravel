# ============================================
# SUPERVISOR CONFIGURATION
# ============================================
#
# PURPOSE: Manage multiple processes in one Docker container
# LOCATION: docker/supervisord.conf
# COPIED TO: /etc/supervisor/conf.d/supervisord.conf
#
# WHAT IS SUPERVISOR:
# - Process control system
# - Keeps processes running
# - Restarts if they crash
# - Manages logs
# - Like systemd, but simpler
#
# WHY NEEDED:
# - Docker containers should run ONE process
# - But we need TWO: Nginx + PHP-FPM
# - Supervisor manages both as "one" process
#
# ALTERNATIVE APPROACHES:
# 1. Two containers (Nginx + PHP-FPM separate)
# 2. Use docker-compose with multiple services
# 3. Use Kubernetes with multiple containers in pod
#
# WHY THIS APPROACH:
# - Simpler deployment (one container)
# - Easier for small applications
# - Nginx and PHP-FPM tightly coupled anyway

# ============================================
# SUPERVISORD MAIN CONFIGURATION
# ============================================

[supervisord]
# nodaemon=true
#
# WHAT IT DOES:
# - Run supervisor in foreground (don't detach)
# - Stay attached to terminal
#
# WHY TRUE:
# - Docker needs a foreground process
# - If supervisor goes to background, container stops
# - Docker thinks "process ended, shut down"
#
# WITH DAEMON (nodaemon=false):
# Container starts → Supervisor backgrounds → Container stops
#
# WITHOUT DAEMON (nodaemon=true):
# Container starts → Supervisor runs → Container keeps running
nodaemon=true

# user=root
#
# WHAT IT DOES:
# - Run supervisor as root user
# - Needed to manage both Nginx and PHP-FPM
#
# WHY ROOT:
# - Nginx master needs root to bind port 80
# - Can then spawn workers as www-data
# - PHP-FPM also needs root to start
#
# SECURITY NOTE:
# - Supervisor runs as root
# - But Nginx workers run as www-data
# - PHP-FPM workers run as www-data
# - Only master processes are root
user=root

# logfile=/var/log/supervisor/supervisord.log
#
# WHAT IT DOES:
# - Where supervisor writes its own logs
# - Not application logs (those are separate)
#
# LOGS CONTAIN:
# - Supervisor start/stop
# - Process start/stop/crash
# - Configuration reloads
# - Errors
#
# VIEW LOGS:
# docker-compose exec app tail -f /var/log/supervisor/supervisord.log
logfile=/var/log/supervisor/supervisord.log

# pidfile=/var/run/supervisord.pid
#
# WHAT IT DOES:
# - Store supervisor's process ID
# - Used for process management
#
# USAGE:
# cat /var/run/supervisord.pid → Get PID
# kill -HUP $(cat /var/run/supervisord.pid) → Reload config
pidfile=/var/run/supervisord.pid

# ============================================
# PHP-FPM PROGRAM CONFIGURATION
# ============================================

[program:php-fpm]
# command=php-fpm8.2 -F
#
# WHAT IT DOES:
# - Start PHP-FPM process
# - php-fpm8.2: PHP FastCGI Process Manager version 8.2
# - -F: Run in foreground (don't daemonize)
#
# WHY FOREGROUND:
# - Supervisor needs to monitor the process
# - If PHP-FPM goes to background, supervisor loses control
# - Can't detect crashes or restart
#
# WHAT PHP-FPM DOES:
# - Listens on port 9000
# - Waits for FastCGI requests from Nginx
# - Executes PHP code
# - Returns HTML/JSON to Nginx
command=php-fpm8.2 -F

# stdout_logfile=/dev/stdout
#
# WHAT IT DOES:
# - Send PHP-FPM stdout to Docker stdout
# - Makes logs visible in: docker-compose logs
#
# WHY /dev/stdout:
# - Docker best practice
# - Centralized logging
# - Easy to view with docker logs
# - Works with log aggregators (ELK, Splunk)
#
# WITHOUT THIS:
# - Logs buried in container filesystem
# - Hard to access
# - Lost when container destroyed
stdout_logfile=/dev/stdout

# stdout_logfile_maxbytes=0
#
# WHAT IT DOES:
# - Don't rotate log files
# - 0 = unlimited size
#
# WHY 0:
# - Docker handles log rotation
# - No need for internal rotation
# - Simpler configuration
stdout_logfile_maxbytes=0

# stderr_logfile=/dev/stderr
#
# WHAT IT DOES:
# - Send PHP-FPM errors to Docker stderr
# - Separate stream from stdout
#
# WHAT GOES HERE:
# - PHP errors (syntax errors, exceptions)
# - PHP-FPM errors (config issues)
# - Warning messages
#
# VIEW ERRORS:
# docker-compose logs app | grep error
stderr_logfile=/dev/stderr

# stderr_logfile_maxbytes=0
#
# WHAT IT DOES:
# - Don't rotate error log
# - Same reason as stdout
stderr_logfile_maxbytes=0

# autorestart=true
#
# WHAT IT DOES:
# - Automatically restart if PHP-FPM crashes
# - Supervisor monitors process
#
# SCENARIOS:
# - PHP-FPM crashes → Supervisor detects → Restarts automatically
# - Memory leak → Process dies → Supervisor restarts
# - Configuration error → Keeps trying to restart
#
# WHY TRUE:
# - High availability
# - Automatic recovery
# - No manual intervention needed
#
# RESTART LOGIC:
# Process exits → Wait brief moment → Start again
autorestart=true

# startretries=3
#
# WHAT IT DOES:
# - Try to start 3 times before giving up
# - Prevents infinite restart loop
#
# WHY 3:
# - Gives enough chances for transient issues
# - Not too many (prevents infinite loops)
# - After 3 failures, stops trying
#
# EXAMPLE:
# Attempt 1: Fail (port in use)
# Attempt 2: Fail (port still in use)
# Attempt 3: Fail (port still in use)
# Give up: Log error, mark as FATAL
startretries=3

# ============================================
# NGINX PROGRAM CONFIGURATION
# ============================================

[program:nginx]
# command=nginx -g 'daemon off;'
#
# WHAT IT DOES:
# - Start Nginx web server
# - -g 'daemon off;': Run in foreground
#
# WHY FOREGROUND:
# - Same reason as PHP-FPM
# - Supervisor needs to monitor
# - Can detect crashes and restart
#
# daemon off;
#   - Nginx configuration directive
#   - Passed as command-line argument
#   - Overrides any daemon on; in config
command=nginx -g 'daemon off;'

# stdout_logfile=/dev/stdout
# stdout_logfile_maxbytes=0
#
# WHAT IT DOES:
# - Send Nginx access logs to Docker stdout
# - See all HTTP requests in docker logs
#
# EXAMPLE LOGS:
# 192.168.1.1 - - [09/Jan/2025:14:30:00] "GET /api/v1/secrets HTTP/1.1" 200
# 192.168.1.1 - - [09/Jan/2025:14:30:05] "POST /api/v1/secrets HTTP/1.1" 201
stdout_logfile=/dev/stdout
stdout_logfile_maxbytes=0

# stderr_logfile=/dev/stderr
# stderr_logfile_maxbytes=0
#
# WHAT IT DOES:
# - Send Nginx errors to Docker stderr
#
# WHAT GOES HERE:
# - Nginx errors (can't bind port)
# - Configuration errors
# - Upstream errors (PHP-FPM down)
# - Client errors (large requests)
stderr_logfile=/dev/stderr
stderr_logfile_maxbytes=0

# autorestart=true
#
# WHAT IT DOES:
# - Restart Nginx if it crashes
# - Ensures web server is always running
#
# SCENARIOS:
# - Nginx crashes → Supervisor restarts
# - Killed by OOM → Supervisor restarts
# - Segmentation fault → Supervisor restarts
autorestart=true

# startretries=3
#
# WHAT IT DOES:
# - Try 3 times before giving up
# - Prevents infinite restart on config errors
#
# EXAMPLE:
# Attempt 1: Fail (port 80 already in use)
# Attempt 2: Fail (still in use)
# Attempt 3: Fail (still in use)
# Give up: Container will exit
startretries=3

# ============================================
# HOW IT ALL WORKS TOGETHER
# ============================================
#
# CONTAINER STARTUP FLOW:
#
# 1. Docker starts container
#    CMD: /usr/bin/supervisord -c /etc/supervisor/conf.d/supervisord.conf
#
# 2. Supervisor starts
#    - Reads configuration
#    - Finds two programs: php-fpm, nginx
#
# 3. Supervisor starts PHP-FPM
#    - Runs: php-fpm8.2 -F
#    - PHP-FPM listens on 127.0.0.1:9000
#    - Supervisor monitors process
#
# 4. Supervisor starts Nginx
#    - Runs: nginx -g 'daemon off;'
#    - Nginx listens on port 80
#    - Supervisor monitors process
#
# 5. Both processes run
#    - Nginx receives HTTP requests
#    - Nginx forwards .php requests to PHP-FPM
#    - PHP-FPM processes PHP code
#    - Returns response through Nginx
#    - Client receives response
#
# 6. If process crashes
#    - Supervisor detects
#    - Restarts automatically
#    - Logs the event
#
# 7. Container stays running
#    - As long as Supervisor runs
#    - Container won't exit unless Supervisor exits
#
# ============================================
# MONITORING SUPERVISOR
# ============================================
#
# Check status:
# docker-compose exec app supervisorctl status
#
# Output:
# nginx                            RUNNING   pid 23, uptime 0:05:32
# php-fpm                          RUNNING   pid 22, uptime 0:05:32
#
# Restart a program:
# docker-compose exec app supervisorctl restart nginx
#
# Stop a program:
# docker-compose exec app supervisorctl stop php-fpm
#
# Start a program:
# docker-compose exec app supervisorctl start php-fpm
#
# Reload config:
# docker-compose exec app supervisorctl reread
# docker-compose exec app supervisorctl update
#
# View logs:
# docker-compose exec app supervisorctl tail php-fpm
# docker-compose exec app supervisorctl tail nginx
#
# ============================================
# TROUBLESHOOTING
# ============================================
#
# Problem: Nginx won't start
# Check: docker-compose exec app supervisorctl status
# Logs: docker-compose exec app supervisorctl tail nginx stderr
# Common: Port 80 already in use, config error
#
# Problem: PHP-FPM won't start
# Check: docker-compose exec app supervisorctl status
# Logs: docker-compose exec app supervisorctl tail php-fpm stderr
# Common: Port 9000 in use, memory limit
#
# Problem: Both processes FATAL
# Check: docker-compose logs app
# Common: Supervisor config error, permission issue
#
# Problem: Container exits immediately
# Check: docker-compose logs app
# Common: Supervisor running in daemon mode (should be nodaemon=true)
#
# ============================================
# ADDING MORE PROGRAMS
# ============================================
#
# Can add more programs to manage:
#
# [program:laravel-queue]
# command=php /var/www/html/artisan queue:work --tries=3
# numprocs=1
# autostart=true
# autorestart=true
# user=www-data
#
# [program:laravel-scheduler]
# command=bash -c "while true; do php /var/www/html/artisan schedule:run >> /dev/null 2>&1; sleep 60; done"
# autostart=true
# autorestart=true
# user=www-data
#
# [program:horizon]
# command=php /var/www/html/artisan horizon
# autostart=true
# autorestart=true
# user=www-data
#
# ============================================
# PRODUCTION CONSIDERATIONS
# ============================================
#
# 1. Resource Limits:
#    - Set PHP-FPM pm.max_children
#    - Limit memory per process
#    - Monitor CPU usage
#
# 2. Log Management:
#    - Use external log aggregator
#    - Set up log rotation in Docker
#    - Monitor log volume
#
# 3. Health Checks:
#    - Add Docker HEALTHCHECK
#    - Monitor process status
#    - Alert on restarts
#
# 4. Graceful Shutdown:
#    - Handle SIGTERM properly
#    - Finish current requests
#    - Don't kill mid-request
#
# ============================================