<?php

namespace App\Services;

use App\Models\Secret;
use App\Repositories\Contracts\SecretRepositoryInterface;
use Illuminate\Support\Facades\Crypt;
use Carbon\Carbon;

/**
 * SECRET SERVICE
 * 
 * PURPOSE: Contains ALL business logic for secrets
 * 
 * RESPONSIBILITIES:
 * 1. Encrypt content before storage
 * 2. Decrypt content when retrieving
 * 3. Handle TTL (Time To Live) logic
 * 4. Coordinate with repository for database operations
 * 5. Return data in format needed by controller
 * 
 * WHY THIS LAYER?
 * - Controllers should be thin (just HTTP handling)
 * - Repositories should only do database operations
 * - Service contains the "business rules" and orchestration
 * 
 * DEPENDENCY INJECTION:
 * - Constructor receives SecretRepositoryInterface
 * - Laravel's IoC container automatically provides implementation
 * - Easy to test by mocking the repository
 * 
 * EXAMPLE FLOW:
 * Controller → Service (business logic) → Repository (database) → Database
 */
class SecretService
{
    /**
     * DEPENDENCY INJECTION via Constructor
     * 
     * WHY CONSTRUCTOR INJECTION:
     * - Dependencies are explicit and required
     * - Laravel automatically resolves dependencies
     * - Easy to mock in tests
     * 
     * TYPE HINT: SecretRepositoryInterface (not concrete class)
     * - Depends on abstraction, not implementation
     * - Can swap database implementations without changing this code
     * 
     * PRIVATE PROPERTY:
     * - Modern PHP syntax (PHP 8+)
     * - Automatically creates property and assigns parameter
     * - Same as writing: 
     *   private SecretRepositoryInterface $secretRepository;
     *   $this->secretRepository = $secretRepository;
     */
    public function __construct(
        private SecretRepositoryInterface $secretRepository
    ) {}

    /**
     * CREATE A NEW SECRET
     * 
     * @param string $content - Plain text secret to store
     * @param int|null $ttl   - Optional Time To Live in minutes
     * @return Secret         - Created secret with UUID
     * 
     * BUSINESS LOGIC FLOW:
     * 1. Receive plain text content
     * 2. Encrypt it using Laravel's Crypt facade
     * 3. Calculate expiration time if TTL provided
     * 4. Store in database via repository
     * 5. Return created secret
     * 
     * ENCRYPTION:
     * - Uses AES-256-CBC (Laravel default)
     * - Key from APP_KEY in .env
     * - Automatically handles IV (initialization vector)
     * 
     * TTL LOGIC:
     * - If TTL provided: expires_at = now + TTL minutes
     * - If TTL not provided: expires_at = null (never expires)
     * 
     * EXAMPLE USAGE:
     * // Create secret that expires in 1 hour
     * $secret = $service->createSecret('my-password', 60);
     * 
     * // Create secret that never expires
     * $secret = $service->createSecret('api-key', null);
     * 
     * WHAT CONTROLLER SEES:
     * - Receives Secret model with uuid, created_at, expires_at
     * - Content is encrypted (controller never sees plain text)
     * - Can build API response using this data
     */
    public function createSecret(string $content, ?int $ttl = null): Secret
    {
        // STEP 1: ENCRYPT THE CONTENT
        // Crypt::encryptString() uses AES-256-CBC
        // Returns base64-encoded encrypted string
        // Example input: "my-secret-password"
        // Example output: "eyJpdiI6IjNMZ0xwOUZ2..."
        $encryptedContent = Crypt::encryptString($content);
        
        // STEP 2: PREPARE DATA FOR DATABASE
        $data = [
            'encrypted_content' => $encryptedContent,
            
            // CALCULATE EXPIRATION TIME
            // If $ttl is provided (e.g., 60 minutes):
            //   expires_at = Carbon::now()->addMinutes(60)
            //   Result: '2025-01-09 15:00:00'
            // If $ttl is null:
            //   expires_at = null (never expires)
            'expires_at' => $ttl ? Carbon::now()->addMinutes($ttl) : null,
        ];

        // STEP 3: SAVE TO DATABASE
        // Repository handles the actual INSERT
        // UUID is auto-generated by model
        // Returns the created Secret instance
        return $this->secretRepository->create($data);
    }

    /**
     * RETRIEVE AND BURN A SECRET (CORE FEATURE)
     * 
     * @param string $uuid - The UUID of the secret to retrieve
     * @return array|null  - Returns decrypted content + metadata, or null if not found
     * 
     * BUSINESS LOGIC FLOW:
     * 1. Find secret by UUID (only if not expired)
     * 2. If not found → return null (404 to user)
     * 3. If found → decrypt content
     * 4. Store metadata before deletion
     * 5. DELETE the secret (burn on read)
     * 6. Return decrypted content + metadata
     * 
     * CRITICAL FEATURE: "BURN ON READ"
     * - Secret is deleted AFTER being retrieved
     * - Can only be read ONCE
     * - Implements self-destructing behavior
     * 
     * WHY RETURN ARRAY (not Secret):
     * - Secret is deleted, so model becomes invalid
     * - Need to preserve data (content, timestamps) after deletion
     * - Array is safer and contains exactly what controller needs
     * 
     * SECURITY CONSIDERATIONS:
     * 1. Decrypt ONLY after successful retrieval
     * 2. Delete IMMEDIATELY after decryption
     * 3. No logging of decrypted content
     * 4. Check expiration BEFORE decryption
     * 
     * ERROR SCENARIOS:
     * - UUID doesn't exist → null
     * - Secret expired → null (findByUuid already filters)
     * - Secret already deleted → null
     * 
     * EXAMPLE USAGE:
     * $result = $service->retrieveAndBurnSecret('550e8400-...');
     * 
     * if ($result) {
     *     echo $result['content'];      // "my-secret-password"
     *     echo $result['created_at'];   // Carbon instance
     *     echo $result['expires_at'];   // Carbon instance or null
     * } else {
     *     // Secret not found or expired
     * }
     */
    public function retrieveAndBurnSecret(string $uuid): ?array
    {
        // STEP 1: FIND THE SECRET
        // Repository checks: uuid match AND not expired
        // Returns: Secret instance or null
        $secret = $this->secretRepository->findByUuid($uuid);

        // STEP 2: CHECK IF FOUND
        if (!$secret) {
            // Secret doesn't exist or has expired
            // Return null → Controller sends 404
            return null;
        }

        // STEP 3: DECRYPT THE CONTENT
        // Crypt::decryptString() reverses the encryption
        // Input: "eyJpdiI6IjNMZ0xwOUZ2..." (encrypted)
        // Output: "my-secret-password" (plain text)
        // 
        // SECURITY NOTE: This is the ONLY place content is decrypted
        // It happens in-memory, never stored decrypted
        $decryptedContent = Crypt::decryptString($secret->encrypted_content);
        
        // STEP 4: PRESERVE METADATA
        // We need this data BEFORE deleting the secret
        // Store in array because model will be gone after delete()
        $metadata = [
            'content' => $decryptedContent,  // The actual secret (plain text)
            'created_at' => $secret->created_at,  // When it was created
            'expires_at' => $secret->expires_at,  // When it would expire
        ];

        // STEP 5: BURN ON READ - DELETE THE SECRET
        // This is the critical "self-destruct" feature
        // Secret is permanently deleted from database
        // Can NEVER be retrieved again
        // 
        // SQL: DELETE FROM secrets WHERE id = ?
        $this->secretRepository->delete($secret);

        // STEP 6: RETURN DECRYPTED DATA
        // Controller will format this for API response
        return $metadata;
    }

    /**
     * CLEANUP EXPIRED SECRETS (MAINTENANCE TASK)
     * 
     * @return int - Number of secrets deleted
     * 
     * PURPOSE: Scheduled task to remove expired secrets
     * 
     * WHY NEEDED:
     * - Secrets with TTL should auto-delete when expired
     * - Prevents database bloat
     * - Maintains security (expired secrets are gone)
     * 
     * WHEN TO RUN:
     * - Via Laravel scheduler (cron job)
     * - Recommended: hourly
     * - Command: php artisan schedule:work
     * 
     * USAGE IN SCHEDULER:
     * In app/Console/Kernel.php:
     * 
     * protected function schedule(Schedule $schedule)
     * {
     *     $schedule->call(function () {
     *         app(SecretService::class)->cleanupExpiredSecrets();
     *     })->hourly()->emailOutputOnFailure('admin@example.com');
     * }
     * 
     * EXAMPLE OUTPUT:
     * Cleaned up 15 expired secrets
     */
    public function cleanupExpiredSecrets(): int
    {
        // Delegate to repository
        // Repository handles the actual DELETE query
        // Returns number of deleted rows
        return $this->secretRepository->deleteExpired();
    }
}